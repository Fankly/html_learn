### 函数(Function)

- #### 简介

  - 函数也是一个对象
  - 它具有其他对象所有的功能
  - 函数中可以存储代码,且可以在需要时调用这些代码

- #### 语法

```js
function 函数名(){
    //语句...
}
//创建一个函数对象
function fn(){
    //语句...
}
```

- #### 调用函数

  - 调用函数就是执行函数中存储的代码
  - 语法
    - 函数对象()

- #### 使用typeof检查函数对象时会返回function

- #### 函数的定义方式

  - 函数声明

  ```js
  function 函数名(){
      语句...
  }
  ```

  - 函数表达式

  ```js
  //匿名函数
  const 变量 = function() {
      语句...
  }
  ```

  - 箭头函数

  ```js
  const fn3 = ()=>{
      多条语句...
  }
   //单条语句{}可以省略不写   
  const fn4 = ()=>console.log("箭头函数");
  ```

- #### 参数

  - ##### 形式参数

    - 在定义函数时,可以在函数中指定数量不等的形式参数(形参)
    - 在函数中定义参数,就相当于在函数内部声明了对应的变量,但是没有赋值

  - ##### 实际参数

    - 在调用函数时,可以在函数的()传递数量不等的实参
    - 实参会赋值给其对应的形参

  - ##### 参数数量

    - 如果实参和形参数量相同,则对应的实参赋值给对应的形参
    - 如果实参多于形参,则多余的实参不会使用
    - 如果形参多于实参,则多余的形参为undefined

  - ##### 参数类型

    - JS中不会检查参数的类型,可以传递任何类型的值作为参数
    
  - ##### 箭头函数的参数
  
    - 当箭头函数只有一个参数时,可以省略()
    - 定义参数时,可以为参数指定默认值
    - 默认值,会在没有对应实参时生效
  
  - ##### 对象可以作为参数
  
    - 对象可以作为参数传递
    - 传递实参时,传递并不是变量本身,而是变量中存储的值
    - 函数每次调用,都会重新创建默认值
  
  - ##### 函数作为参数
  
    - 在JS中,函数也是一个对象(一等函数)
      - 别的对象能做的事情,函数也可以
  
- #### 函数的返回值

  - ##### 在函数中,可以通过return关键字来指定函数的返回值
    
    - 返回值就是函数的执行结果,函数调用完毕返回值便会作为结果返回
  - ##### 任何值都可以作为返回值使用(包括对象和函数之类)
    
    -  如果return后不跟任何值,则相当于返回undefined
    - 如果不写return,那么函数的返回值依然是undefined
  - ##### return一执行函数立即结束
  - ##### 箭头函数的返回值可以直接写在箭头后'
    
    - 如果直接在箭头后设置对象字面量为返回值,对象字面量必须使用()括起来

- #### 作用域

  - ##### 作用域指的是一个变量的可见区域
  - ##### 作用域有两种
    
    - 全局作用域
      - 全局作用域在网页运行时创建,在网页关闭时消耗
      - 所有直接编写到script标签中的代码都位于全局作用域中
      - 全局作用域中的变量是全局变量,可以在任意位置访问
    - 局部作用域
      - 块作用域
        - 块作用域是一种局部作用域
        - 块作用域在代码块执行时创建,代码块执行完毕它就销毁
        - 在块作用域中声明的变量是局部变量,只能在快内部访问,外部无法访问
      - 函数作用域
        - 函数作用域也是一种局部作用域
        - 函数作用域在函数调用时产生,调用结束后销毁
        - 函数每次调用都会产生一个全新的函数作用域
        - 在函数中定义的变量是局部变量,只能在函数内部访问,外部无法访问
  - ##### 作用域链
    
    - 当我们使用一个变量时
      - JS解释器会优先在当前作用域中寻找变量
        - 如果找到了则直接使用
        - 如果没找到,则去上一层作用域中寻找,找到了则使用
        - 如果没找到,则继续去上一层寻找,依次类推
        - 如果一直到这个全局作用域都没找到,则报错 xxx is not defined
  
- #### window对象

  - ##### 在浏览器中,浏览器为我们提供了一个window对象,可以直接访问
  - ##### window对象代表的是浏览器窗口,通过该对象可以对浏览器窗口进行各种操作
    
    - 除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象
    
  - ##### window对象的属性可以通过window对象访问,也可以直接访问
  - ##### 函数就可以认为是window对象的方法
  - ##### var用来声明变量,作用和let相同,但是var不具有块作用域,但有函数作用域
    
    - 在全局中使用var声明的变量,都会作为window对象的属性保存
    - 使用function声明的函数,都会作为window的方法保存
    - 使用let声明的变量不会存储在window,而存在一个秘密的小地方(无法访问)
    - 当window.c和let c同时存在的时候,会先去寻找let c
    
  - ##### 在局部作用域中,如果没有使用var或let声明变量,则变量会自动成为window对象的属性,也就是全局变量

- #### 提升

  - ##### 变量的提升

    - 使用var声明的变量,它会在所有代码执行前被声明
      - 所以我们可以在变量声明前就访问变量

  - ##### 函数的提升
    
    - 使用函数声明创建的函数,会在其他代码执行前被创建
      - 所以我们可以在函数声明前调用函数
    
  - ##### let声明的变量实际也会提升,但是在赋值之前解释器禁止访问该变量

- #### 练习

```js
//第一道题
var a = 1
function fn(){
    a = 2
    console.log(a) //2
}
fn()
console.log(a) //2

//变量和函数的提升同样适用于函数作用域

//第二道题
var a = 1
function fn(){
    console.log(a) //undefined
    var a = 2
    console.log(a) //2
}
fn()
console.log(a) //1


//定义形参就相当于在函数中声明了对应的变量,但是没有赋值
//第三道题
var a = 1
function fn(a){
    console.log(a) //undefined
    a = 2
    console.log(a) // 2
}
fn()
console.log(a) // 1

//第四道题
var a = 1
function fn(a){
    console.log(a) //10
    a = 2
    console.log(a) // 2
}
fn(10)
console.log(a) // 1

//第五道题
var a = 1
function fn(a){
    console.log(a) //1
    a = 2
    console.log(a) // 2
}
fn(a)
console.log(a) // 1

//第六道题
console.log(a) // fn(5)
var a = 1
console.log(a)//1
function a(){
    alert(2)
}
function a(){
    alert(5)
}
console.log(a)//1
var a = 3
console.log(a)//3
var a = function(){
    alert(4)
}
console.log(a)//fn(4)
var a
console.log(a)//fn(4)
```

- #### debug

  - ##### debugger //在代码中打了一个断点

  - #####  浏览器设置断点

- #### 立即执行函数

  - ##### 开发中应该尽量减少在全局作用域中编写代码

  - ##### 所以我们的代码要尽量编写的局部作用域

  - ##### 如果使用let声明的变量,可以使用{}来创建块作用域

  - ##### 如果使用var声明的变量,可以使用function来创建函数作用域

  ```js
  
  //希望可以创建一个只执行一次的匿名函数,防止function开头的函数被提升
  
  //方式一
  (function(){
      var a  = 10;
  })()
  
  //方式二
  (function(){
      var a  = 10;
  }())
  ```

  - ##### 立即执行函数(IIFE)

    - 立即是一个匿名的函数,并它只会调用一次
    - 可以利用IIFE来创建一次性的函数作用域,避免变量冲突的问题

    ```js
    (function(){
        var a  = 10;
    }())
    
    (function(){
        var a  = 11;
    }())
    
    //会被解析成(xxx)(xxx),当成一个整体,解决方案在后面加上分号即可
    ```

- ####  函数中的this

  - ##### this

    - 函数在执行时,JS解释器每次都会传入一个隐含的参数
    - 这个参数就叫做this
    - this会指向一个对象
      - this所指向的对象会根据函数调用方式的不同而不同
        - 以函数形式调用时,this指向的时window 
        - 以方法的形式调用时,this指向的是调用方法的对象
    - 通过this可以在方法中引用调用方法的对象

    ```js
    const obj3 = {
        name:"沙和尚",
        sayHello:function(){
            console.log(this.name)
        }
    }
    ```

  - ##### 箭头函数中的this

    - 箭头函数

      - ([参数]) => 返回值

    - 举例

      ```js
      - 无参箭头函数:() => 返回值
      - 一个参数的: a => 返回值
      - 多个参数的: (a,b) => 返回值
      
      - 只有一个语句的函数: ()=>返回值
      - 只返回一个对象的函数:()=>({...})
      - 有多行语句的函数: () => {
          ...
          return 返回值
      }
      
      //如果函数的属性名和变量名一样,变量名可以省略
      //函数的方法中,function可以省略
      
      const fn(){
          console.log("fn-->",this)
      }
      const fn2 = ()=>{
          console.log("fn2-->",this)//总是window
      }
      const obj = {
          name:"孙悟空"
          fn,
          fn2,
          sayHello(){
              console.log(this.name)
              function t(){
                  console.log("t-->",this) // window
              }
              const t2 = () => {
                  console.log("t2-->",this)
                  t2() // obj
              }
          }
      }
      
      obj.fn() // obj
      obj.fn2() // window
      ```

    - 箭头函数没有自己的this,它的this由外层作用域决定

      - 箭头函数的this和它的调用方式无关

- #### 严格模式

  - ##### 正常模式

    - 默认情况下代码都运行在正常模式中
      - 在正常模式,语法检查并不严格
      - 它的原则是:能不报错的地方尽量不报错
    - 这种处理方法导致代码的运行性能较差

  - ##### 严格模式

    - 在严格模式下,语法检查变得严格
      - 禁止一些语法
      - 更容易报错
      - 提升了性能
    - 开启严格模式
      - 全局开启
        - "use strict"
      - 函数开启
        - 在函数开头写"use strict"
    - 在开发中,应该尽量使用严格模式
      - 这样可以将一些隐藏的问题消灭在萌芽阶段
      - 同时也能提升代码的运行性能
